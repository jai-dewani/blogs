{"componentChunkName":"component---src-templates-blog-post-js","path":"/fun-mark/","result":{"data":{"site":{"siteMetadata":{"title":"Blogs by JaiD"}},"markdownRemark":{"id":"2e52897b-0bed-59ea-970d-841a6d6d35ed","excerpt":"Before starting the blog I wanted to say that this is my first PyPI package and it is still in the development phase so if anyone finds it interesting, makeâ€¦","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/48f83e9e44df924ef02160722b252e28/166a3/funmark.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAC4jAAAuIwF4pT92AAAA3ElEQVR42pWSyw5EMBSG5/1fxF4kFhKRWHoBFixY0AoGbdWtnZNKTIeRMV+6aM+l/9/Lo6qqaZoGBWOMD3wbgwZT6BEhRBzHD0KIlFIo5D22yizL3s1BEHieV9d1WZZPBZjqux5j7Pu+67qO42CEu647NgNFUYATsEcpBWPjOCKEYCPOeZqmYRgmSUJ6KCdflM/GmqYB/avsR7N+7G0C+tB/yO6TS2W4/2VZ2raFY8/zvK7rD2U9EUWRZVm2bZumaRhGnufnmktlkIU42KYKWN5S/u+d9x/Gb7P/sBePN3pRmT3rdwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"funmark\"\n        title=\"\"\n        src=\"/blogs/static/48f83e9e44df924ef02160722b252e28/5a190/funmark.png\"\n        srcset=\"/blogs/static/48f83e9e44df924ef02160722b252e28/772e8/funmark.png 200w,\n/blogs/static/48f83e9e44df924ef02160722b252e28/e17e5/funmark.png 400w,\n/blogs/static/48f83e9e44df924ef02160722b252e28/5a190/funmark.png 800w,\n/blogs/static/48f83e9e44df924ef02160722b252e28/c1b63/funmark.png 1200w,\n/blogs/static/48f83e9e44df924ef02160722b252e28/29007/funmark.png 1600w,\n/blogs/static/48f83e9e44df924ef02160722b252e28/166a3/funmark.png 1980w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Before starting the blog I wanted to say that this is my first PyPI package and it is still in the development phase so if anyone finds it interesting, make sure to checkout funmark in <a href=\"https://github.com/jai-dewani/fun-mark\">GitHub</a></p>\n<p>Funmark is a python package that can be used for function benchmarking and then to analyze/compare their runtime and memory consumption using graph plots.</p>\n<p>In this blog I will be using my funmark package to benchmark sorting functions, mainly</p>\n<ul>\n<li>QuickSort</li>\n<li>MergeSort</li>\n<li>TimSort</li>\n</ul>\n<p>Let's Start by first importing funmark and random.randint() for creating random arrays</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import funmark\nfrom random import randint</code></pre></div>\n<p>Let's create functions for each sorting method</p>\n<h2>QuickSort</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def partition(arr,low,high): \n    i = ( low-1 )         # index of smaller element \n    pivot = arr[high]     # pivot \n    for j in range(low , high): \n        if   arr[j] &lt; pivot: \n            i = i+1 \n            arr[i],arr[j] = arr[j],arr[i] \n  \n    arr[i+1],arr[high] = arr[high],arr[i+1] \n    return ( i+1 ) \n\ndef quickSort(argv): \n    arr = argv[0]\n    low = argv[1]\n    high = argv[2]\n    if low &lt; high: \n        pi = partition(arr,low,high) \n        quickSort([arr, low, pi-1]) \n        quickSort([arr, pi+1, high]) </code></pre></div>\n<h2>MergeSort</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def mergeList(arr, l, m, r): \n    n1 = m - l + 1\n    n2 = r- m \n    L = [0] * (n1) \n    R = [0] * (n2) \n    for i in range(0 , n1): \n        L[i] = arr[l + i] \n    for j in range(0 , n2): \n        R[j] = arr[m + 1 + j] \n    i = 0     \n    j = 0 \n    k = l     \n    while i &lt; n1 and j &lt; n2 : \n        if L[i] &lt;= R[j]: \n            arr[k] = L[i] \n            i += 1\n        else: \n            arr[k] = R[j] \n            j += 1\n        k += 1\n    while i &lt; n1: \n        arr[k] = L[i] \n        i += 1\n        k += 1\n    while j &lt; n2: \n        arr[k] = R[j] \n        j += 1\n        k += 1\n\ndef mergeSort(argv):\n    arr = argv[0]\n    l = argv[1]\n    r = argv[2]\n    if l &lt; r: \n        m = (l+(r-1))//2 \n        mergeSort([arr, l, m]) \n        mergeSort([arr, m+1, r]) \n        mergeList(arr, l, m, r) </code></pre></div>\n<h2>TimSort</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def timSort(argv):\n    ar = argv[0]\n    ar.sort()\n    return ar</code></pre></div>\n<h2>BenchMarking the above functions</h2>\n<p>Lets create funmark.Benchmark() objects for each functions</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">merge = funmark.Benchmark()\nquick = funmark.Benchmark()\ntim = funmark.Benchmark()</code></pre></div>\n<p>Now lets create random arrays of sizes ranging from</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">listSize = 10\nmaxSize = 10**6\nwhile listSize &lt; maxSize:\n    ar = [randint(1,10**5) for listSize in range(listSize)]\n    \n    time, memory = merge.run(quickSort, ar, 0, len(ar)-1)\n    merge.add(len(ar), time, memory)\n    \n    time, memory= quick.run(mergeSort, ar, 0, len(ar)-1)\n    quick.add(len(ar), time, memory)\n\n    time, memory = tim.run(timSort, ar)\n    tim.add(len(ar), time, memory)\n\n    listSize = int(2*listSize)</code></pre></div>\n<p>For each function, I am running .run(function Name, parameter) to get their runtime and memory usage, and then I am saving them to their respective objects using .add(size, time, memory)\nAt the last line of while loop and increasing the size of listSize so that we can get these values for different sizes of the list</p>\n<h2>Plotting comparison graphs</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">merge.compareTime(\"Length\", \"Time\", \"Compression between Sorting Algorithms\", quick, tim)</code></pre></div>\n<p>Here I am plotting the graph of time with <em>merge</em> and passing <em>quick</em> and <em>tim</em> to plot all of them together, here is the result of this line</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/8be848e3a8b78882aee8c41ab0743d57/6af66/time.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA9hAAAPYQGoP6dpAAABiklEQVR42nWTiW7CMAyGef8nRPRIC5XGyihpkuY+9jfhKBqzUssJ+vhtJ96lh8UY3cOMMTab1vq5Ld4790R2+DjnjPHpNjdNczgcTqcTIaTruuPxWFUVtoj7vq/ruuvI1/mslAoh3GEYnWc682EYwOO/SiKwZxCy4SBqbiRXWt9hIZbr9XtZLhBs2xbppY8GVN2SFT4EiN9hVAU1nYtEXAS30OqCT8uUrETovX/B6Aql9A+zIb1JyzV5W45eMBhshBClBx/MiCSnVbmQIRrrtM7wjFZRyhh7Vy6pOmDR8HLkfGDKztK9YMhCU0q5Uc4kykOqYb1V68IsgaEl4UPN0H8oZw81TREbn8BAELLPrN5gbNDtUKqCVzenmHSBQk3hTYVHPvEDjOspNUerLLvyRTIdlfm3g28wKKQ9/pyGsT9zetN8cVhC5MUtL/6+HF4E+qVfzxNXNV7GbjiSvm1IU5Nm9W29P+zhS0x6UjXVGnTE5fHYbacqjw6+dYCQ2zRNfddvR2r1+dcyVb+xoWeapjFYYwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Image\"\n        title=\"\"\n        src=\"/blogs/static/8be848e3a8b78882aee8c41ab0743d57/6af66/time.png\"\n        srcset=\"/blogs/static/8be848e3a8b78882aee8c41ab0743d57/772e8/time.png 200w,\n/blogs/static/8be848e3a8b78882aee8c41ab0743d57/e17e5/time.png 400w,\n/blogs/static/8be848e3a8b78882aee8c41ab0743d57/6af66/time.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>As you can see QuickSort even though has bigger worst case time complexity that MergeSort, its average case is much better due to</p>\n<ul>\n<li>\n<p>Auxiliary Space: Quicksort is an in-place sorting algorithm.  Merge sort on the other hand requires a temporary array to merge the sorted arrays and hence it is not in-place.</p>\n</li>\n<li>\n<p>Worst case: The worst case of quicksort O(n^2) can be avoided by using randomized quicksort. It can be easily avoided with high probability by choosing the right pivot.</p>\n</li>\n<li>\n<p>Locality of reference: Quicksort in particular exhibits good cache locality and this makes it faster than merge sort in many cases like in a virtual memory environment.</p>\n</li>\n<li>\n<p>Tail recursion: QuickSort is tail recursive while Merge sort is not. A tail recursive function is a function where a recursive call is the last thing executed by the function. They are considered better than non tail recursive functions as they can be optimized by the compiler before execution.</p>\n</li>\n</ul>\n<p>And Tim Sort performs exceptionally better than both as expected, hence it's better to use python's in-build .sort() method as long as your need is plain sorting.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">merge.compareMemory(\"Length\", \"Time\", \"Compression between Sorting Algorithms\", quick, tim)</code></pre></div>\n<p>Here I am plotting the graph of memory with <em>mergeSort</em> and passing <em>quickSort</em> and <em>timSort</em> to plot all of them together, here is the result of this line</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/1decbf7e2ddee7bd9904eb94ace21dd2/6af66/memory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAA9hAAAPYQGoP6dpAAABZklEQVR42oWTi3KDIBBF8/9fmIkomthp2sQnREBAeoH4StPpjm4WZk7uXWQPbo5pmvQcSqkxhJRyWcZstF6QQ/zB9r1usiw7nU6Xy4VSmuf5+XxOkgRL1EVREEJQfF6vQgzWWg9DEH/ftG3bs7Is0zRljEUjiKWwPkIlejUwIeUTbtuuaW6PxzcEIQ577m1Y44ba6cFYK4R42u66DsJK+67QYRTcRFiOwpPGN2yMWWHOed/3v5gZw77snezcZOPuCqOVpmkg/l4wWh0f684WrqoKMMTjAe6tDp60ekvuYDTJQ8zwYrULVqcXcgfDLZR3PUPKWx1+Y68wXlT4tlM8D7T3zuqfMGTDgVmnmJPM/Rc72N8T/6k/Ov7F9MBG1iuGzEbONY9FyM9H4soLud5tztm9uuVlkdKUZITQNBbH0xEZdZKRrKAkTbCkOdVhPA7bqfJzFMYJV81oU9d1kRfbkfJZjcv9/QGYWGib3rTPcAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Image\"\n        title=\"\"\n        src=\"/blogs/static/1decbf7e2ddee7bd9904eb94ace21dd2/6af66/memory.png\"\n        srcset=\"/blogs/static/1decbf7e2ddee7bd9904eb94ace21dd2/772e8/memory.png 200w,\n/blogs/static/1decbf7e2ddee7bd9904eb94ace21dd2/e17e5/memory.png 400w,\n/blogs/static/1decbf7e2ddee7bd9904eb94ace21dd2/6af66/memory.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>The plot for QuickSort is just below the TimSort plot hence it isn't clearly visible in this plot but from this we can understand that MergeSort requires extra space whereas QuickSort and TimSort don't!</p>\n<p>This was just a simple analysis of Sorting Algorithms but funmark can be used to do benchmark and analysis for any python code as long as it can be written in a function.</p>\n<p>If you liked what this library can do then check it out on <a href=\"https://github.com/jai-dewani/fun-mark\">github</a> and drop a star and look into the issue tab if you want to contribute!</p>","frontmatter":{"title":"Benchmarking python functions using funmark and plot comparision results","date":"February 22, 2020","description":"I have been working this pypi library called funmark which allows anyone to calculate runtime and memory usage of their functions and plot these results comparing their performance with other similar functions"}},"previous":null,"next":{"fields":{"slug":"/hashcode-2020/"},"frontmatter":{"title":"HashCode 2020 Experience and how to approach it for the first time"}}},"pageContext":{"id":"2e52897b-0bed-59ea-970d-841a6d6d35ed","previousPostId":null,"nextPostId":"c40f0fbe-01b1-551c-898f-22f36e601428"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}