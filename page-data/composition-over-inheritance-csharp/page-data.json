{"componentChunkName":"component---src-templates-blog-post-js","path":"/composition-over-inheritance-csharp/","result":{"data":{"site":{"siteMetadata":{"title":"Blogs by JaiD"}},"markdownRemark":{"id":"104acc39-52be-5550-b2b8-ce8109f3fe28","excerpt":"This post is a summary with some of my personal opinions on this post on Reddit - Why \"composition over inheritance\" is still hard in C# Somehow I have felt…","html":"<blockquote>\n<p>This post is a summary with some of my personal opinions on this post on Reddit - <a href=\"https://www.reddit.com/r/csharp/comments/1mpiqmz/why_composition_over_inheritance_is_still_hard_in/?share_id=XhntU5Nhp8bkMygmQZslj&#x26;utm_content=1&#x26;utm_medium=ios_app&#x26;utm_name=iossmf&#x26;utm_source=share&#x26;utm_term=22\">Why \"composition over inheritance\" is still hard in C#</a></p>\n</blockquote>\n<p>Somehow I have felt this issue, but recently learned the problem isn't a personal one but more generic.\nTIL: “Prefer composition over inheritance.” It’s a common design principle meant to avoid fragile class hierarchies. But if you’re a C# developer, you’ve probably noticed something: inheritance is easy, while composition often feels like a chore.</p>\n<p>Let’s explore why, what the community says about it, and how other languages (like Go) approach the problem.</p>\n<h2>Inheritance is effortless in C#</h2>\n<p>C# makes inheritance ridiculously convenient. Want to extend a class? It’s literally one line:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyButton</span> <span class=\"token punctuation\">:</span> <span class=\"token type-list\"><span class=\"token class-name\">Button</span></span> \n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// override OnClick or add custom behavior</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And that’s it — you instantly get all of <code class=\"language-text\">Button</code>’s behavior, plus your own.</p>\n<h2>Composition is boilerplate-heavy</h2>\n<p>Now let’s try the same idea using composition:</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre class=\"language-csharp\"><code class=\"language-csharp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyButton</span> \n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Button</span> _button <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token constructor-invocation class-name\">Button</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> _button<span class=\"token punctuation\">.</span><span class=\"token function\">Draw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Click</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> _button<span class=\"token punctuation\">.</span><span class=\"token function\">Click</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token return-type class-name\"><span class=\"token keyword\">void</span></span> <span class=\"token function\">Resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> _button<span class=\"token punctuation\">.</span><span class=\"token function\">Resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// …and dozens more methods to delegate</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Notice the problem? You’re writing tons of glue code just to forward calls to the underlying object. No special syntax exists to reduce this boilerplate.</p>\n<p>That friction alone pushes many developers back toward inheritance, even when composition would be a better long-term choice.</p>\n<h2>Frameworks don’t help</h2>\n<p>It’s not just the syntax. Many .NET frameworks (WinForms, WPF, Unity) were designed around subclassing.</p>\n<p>They expect you to override <code class=\"language-text\">OnX</code> methods and extend classes directly. Over time, this leads to brittle hierarchies that are hard to untangle.</p>\n<p>As one developer put it:</p>\n<blockquote>\n<p>“I’ve wasted months untangling WinForms inheritance chains… absolute nightmare.”</p>\n</blockquote>\n<h2>The button example: subclass explosion</h2>\n<p>A classic illustration is the humble UI button.</p>\n<ul>\n<li>You want a blue button → subclass.</li>\n<li>You want a pill-shaped button → subclass.</li>\n<li>You want a button that logs clicks → subclass again.</li>\n</ul>\n<p>Suddenly, you’re juggling classes like <code class=\"language-text\">BluePillLoggingButton</code> and <code class=\"language-text\">RoundedRedButtonWithAnalytics</code>.</p>\n<p>With composition, you could build a <code class=\"language-text\">Button</code> that has a <code class=\"language-text\">ColorBehavior</code>, a <code class=\"language-text\">ShapeBehavior</code>, and a <code class=\"language-text\">LoggingBehavior</code>. Each concern stays separate, and you don’t drown in subclasses.</p>\n<p>The catch: in C#, composition means writing all those delegate methods by hand.</p>\n<h2>What other languages do better</h2>\n<p>Languages like Kotlin or Go provide syntax that makes composition less painful.</p>\n<p>In Kotlin, you can delegate automatically:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> <span class=\"token function\">LoggingRepository</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">private</span> <span class=\"token keyword\">val</span> repo<span class=\"token operator\">:</span> Repository<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> Repository <span class=\"token keyword\">by</span> repo <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">save</span><span class=\"token punctuation\">(</span>item<span class=\"token operator\">:</span> Item<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Logging save\"</span></span><span class=\"token punctuation\">)</span>\n        repo<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>That <code class=\"language-text\">by repo</code> forwards all the methods for you.</p>\n<p>In Go, there’s embedding:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Engine <span class=\"token keyword\">struct</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>e Engine<span class=\"token punctuation\">)</span> <span class=\"token function\">Start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Engine starting...\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Car <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Engine  <span class=\"token comment\">// embedded, not just a field</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c Car<span class=\"token punctuation\">)</span> <span class=\"token function\">Drive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    c<span class=\"token punctuation\">.</span><span class=\"token function\">Start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// method is accessible directly!</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Car driving...\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Go’s embedding is essentially composition with inheritance-like syntax. No boilerplate, but still flexible.</p>\n<h2>Community strategies in C#</h2>\n<p>Since C# doesn’t support delegation out of the box, developers resort to:</p>\n<ul>\n<li>Source generators to auto-generate forwarding methods</li>\n<li>Dynamic proxies for runtime delegation</li>\n<li>Mixin libraries to simulate traits</li>\n<li>Or just sticking with inheritance when it’s “good enough”</li>\n</ul>\n<p>Others have suggested a hybrid approach: use composition for flexible behaviors, inheritance for core identity, and aggressively seal classes to prevent hierarchy sprawl.</p>\n<h2>The takeaway</h2>\n<p>Composition often produces cleaner, more modular code. But in C#, it comes at a cost: inheritance is one line, composition is 30 lines of boilerplate.</p>\n<p>Until the language itself adds built-in delegation or mixin support, “prefer composition over inheritance” will remain easier said than done.</p>","frontmatter":{"title":"Is “Composition over Inheritance” Hard in C#?","date":"October 02, 2025","description":"Exploring why C# makes inheritance effortless with simple syntax while composition requires extensive boilerplate code for method delegation. A look at how other languages like Go and Kotlin solve this problem and what strategies C# developers use to work around these limitations."}},"previous":{"fields":{"slug":"/deffered-ienumerable/"},"frontmatter":{"title":"IEnumerable execution is deferred"}},"next":{"fields":{"slug":"/cqrs-pattern/"},"frontmatter":{"title":"CQRS - Split Personality Disorder for Your Data (And Why That's Actually Good)"}}},"pageContext":{"id":"104acc39-52be-5550-b2b8-ce8109f3fe28","previousPostId":"2dfcefc4-1198-56cf-bb41-370e7643cc10","nextPostId":"fbacf063-0ebc-583b-900b-07f280e3cfb4"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}